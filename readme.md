## Multithreaded Socket Authentication 

### Usage

In Linux system, you need to first install openssl, which is used for AES-256 encryption.

```
sudo apt-get install openssl-lib cmake
```

In the project folder, perform the following commands

```
mkdir build
cd build
cmake ..
make
```

and it will automatically find the openssl include directory and libraries. If not found, you can also compile the server and client source file manually (on OS X):

```
gcc client.c -I/usr/local/Cellar/openssl/1.0.2l/include/ -L/usr/local/Cellar/openssl/1.0.2l/lib/ -lssl -lcrypto -o client

gcc server.c -o server -lpthread -I/usr/local/Cellar/openssl/1.0.2l/include/ -L/usr/local/Cellar/openssl/1.0.2l/lib/ -lssl -lcrypto
```

After all, you will have the `server` and `client` program.

##### Generate symmetric key

The encryption algorithm here we use is AES-256 which requires a 256 bits long key and a 128 bits long initial vector (iv). In my project, I use the the system random number to generate the key and iv.

```
Key:	62668e4cfe963684ed1a9f9c4fc3d5128d1495c2fc4dea3cbddd0c6fb3399a04
IV:		2b1e923005fdc2526d5cd2f5599670e9
```

Numbers generated by the rand and random APIs are not cryptographically secure. In OS X, given the same initial seed value, both functions reproducibly generate a consistent sequence of values each time you run them, and neither generates an equally distributed set of possible values.

In OS X, we get cryptographically secure pseudorandom numbers by reading bytes from the `/dev/random` device file. Each byte from this file is a cryptographically random value from 0-255. By concatenating these bytes, you can generate a random number of an arbitrary size.

For Linux, the only difference is that the random bytes are read from `/dev/urandom`.

To generate a symmetric key, use `-g` option for the client program

```
./client -g
```

##### Experiment

```
./server (terminal 1)
./client (terminal 2)
```

The sample output would be like

```
[SOCKET] Socket created
[SOCKET] Connected
Current local time and date:
	Sun Nov  5 03:02:16 2017

Plain Text:
	127.0.0.1

Hash Value:
	82423d5ccf434cf05dd926d622fb19b7

Generate Signature:
	1c8f54100f1b353e
	18b210f222743beb
	03ddaa700ef66254
	1df16c8df8b64271
	25f69b2d18a86ae8
	5a51ffd458ffabb0
	4f82e2fe7f00
package:
	30323253756e204e
	6f76202035203033
	3a30323a31362032
	3031370a3132372e
	302e302e31303033
	36d31c8f54100f1b
	353e18b210f22274
	3beb03ddaa700ef6
	62541df16c8df8b6
	427125f69b2d18a8
	6ae85a51ffd458ff
	abb04f82e2fe7f30
	30333000

[SOCKET] Socket Send 100 Bytes
Plain Text Received:
	True
```

```
[SOCKET] Socket created
[SOCKET] Bind Done
[SOCKET] Waiting for incoming connections...
[SOCKET] Connection accepted
[PTHREAD] Handler assigned
=====================================
Plaintext Length: 34
Plaintext:
	Sun Nov  5 03:02:16 2017
127.0.0.1

Signature Length: 54
Ciphertext Signature:
	1c8f54100f1b353e
	18b210f222743beb
	03ddaa700ef66254
	1df16c8df8b64271
	25f69b2d18a86ae8
	5a51ffd458ffabb0
	4f82e2fe7f00
Hash Value:
	82423d5ccf434cf05dd926d622fb19b7

Hash Value From Plain Text:
	82423d5ccf434cf05dd926d622fb19b7

Hash Value Match

[SOCKET] Client disconnected
```



